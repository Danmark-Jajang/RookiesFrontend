/**
 * 객체, 키:값의 구조로 이루어진 컬렉션 타입 -> 데이터의 순서는 없다
 *  - 클래스 형태를 표방, 객체지향 스타일을 지향하기 위해
 *      - 상속, 재정의, 생성자, 맴버의 개념 존재
 *  - {}를 사용해 표현
 *  - JS의 객체 생성 방식(5 way)
 *      - 객체 리터럴
 *          - 개많이 사용
 *      - object 구현/확장
 *          - 인기가 없음
 *      - 생성자 함수
 *          - memory상의 낭비 존재가능성 있음
 *      - 생성자 함수 + 프로토타입 확장
 *          - 객체를 표현하는 가장 본질적인 방법
 *      - class 구현
 *          - ES Next에서 추가됨
 *          - 초창기 react개발 시 주력으로 사용 -> legacy
 *              - react에서 훅이 추가되면서 함수형에서도 class형의 기능들을 대체할 수 있게 된다
 *          - 4번째 방법을 일반적인 클래스 형식을 도입하여 표현한 것(포장)
 *
 * 
 *  - 객체
 *      - 이세상에 존재하는 모든 유,무형 존재(Entity)를 표현하기 위해 문법적 방식이 필요 -> class
 *      - class문법을 이용해 Entity를 코드로 표현
 *      - 객체는 class로 작성한 내용을 메모리에 띄운 것 -> 여러번 생성 가능, 메모리상의 주소 가짐
 *      - 특정 변수가 객체를 참조하면, 객체를 참조하는 변수(참조형 변수)가 된다
*/

//1. 객체 리터럴 -> { ... }
// `1회성`으로 여러개의 데이터를 전달할 때 사용
const obj = {};
console.log(obj, typeof obj)

let height = 175; // 전역변수
let w = `weight`; // 동적속성명 샘플, 이 값을 key로 사용하고자 함

const obj1 = {
    //데이터(데이터 관점)/맴버(OPP 관점)
    // key : value(Any type), ...
    name:`JS`,
    age:33,
    height, //전역변수를 맴버/데이터롤 추가 가능, 변수명이 key가 되고 그 값이 value가 됨
    //동적 속성명 추가 가능
    [w]:60, // weight:60, computed property names
    spec:{},
    //함수
    getAge:()=>{
        //객체 내 맴버를 참조할 수 있다(this)
        return `${this.name}의 나이는 ${this.age}이다.`
    },
}

console.log(obj1)


//4. 생성자 + 프로토타입